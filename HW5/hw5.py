# -*- coding: utf-8 -*-
"""HW5 ECE661.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1V6opBwC4-ut4U4x4yMNxUPyo2jrPgwQR
"""

import numpy as np
import matplotlib.pyplot as plt
import cv2 as cv
from skimage import io, draw
from scipy import optimize

#getting keypoints using SIFT
def SIFT_algo(img1,img2):
    img1_op = np.copy(img1)
    img1 = cv.cvtColor(img1,cv.COLOR_BGR2GRAY)
    img2_op = np.copy(img2)
    img2 = cv.cvtColor(img2,cv.COLOR_BGR2GRAY)

    SIFT = cv.SIFT_create()

    kp1,des1 = SIFT.detectAndCompute(img1,None)
    kp2,des2 = SIFT.detectAndCompute(img2,None)

    bf_matcher = cv.BFMatcher(cv.NORM_L2,crossCheck=True)

    matches = bf_matcher.match(des1,des2)

    matches = sorted(matches,key= lambda x: x.distance)

    p = 100 #top p matches
    matches = matches[:p]
    sorted_kp1 = [(int(kp1[match.queryIdx].pt[0]),int(kp1[match.queryIdx].pt[1])) for match in matches]
    sorted_kp2 = [(int(kp2[match.trainIdx].pt[0]),int(kp2[match.trainIdx].pt[1])) for match in matches]

    # op_img = cv.drawMatches(img1_op,kp1,img2_op,kp2,matches[:p],None,flags=cv.DrawMatchesFlags_NOT_DRAW_SINGLE_POINTS)
    # plt.imshow(op_img[:,:,::-1])
    # plt.show()

    # Combined img with correspondences
    height = max(img1.shape[0], img2.shape[0])
    width = img1.shape[1] + img2.shape[1]
    combined_img = np.zeros((height, width, 3), dtype=np.uint8)
    combined_img[:img1.shape[0], :img1.shape[1]] = img1_op
    combined_img[:img2.shape[0], img1.shape[1]:] = img2_op
    # lines for corresponding points
    for pt1, pt2 in zip(sorted_kp1, sorted_kp2):
        pt2_shifted = (pt2[0] + img1.shape[1], pt2[1])
        cv.line(combined_img, pt1, pt2_shifted, (0, 255, 0), 1)

    plt.imshow(combined_img[:,:,::-1])
    plt.title('all correspondences')
    plt.show()

    return [sorted_kp1,sorted_kp2]


# kp1, kp2 = SIFT_algo(image1,image2)
# print(kp1)
# print(kp2)

#get homography
def find_H(img_d,img_r):
    b = img_r.flatten()
    A = np.zeros((2*len(img_d),8))
    #print(A.shape,b.shape)

    for i,pt in enumerate(img_d):
        A[2*i,:] =  np.array([pt[0],pt[1],1,0,0,0,-pt[0]*img_r[i][0],-pt[1]*img_r[i][0]])
        A[2*i+1,:] =  np.array([0,0,0,pt[0],pt[1],1,-pt[0]*img_r[i][1],-pt[1]*img_r[i][1]])

    x = np.linalg.pinv(A)@b

    H = np.array([[x[0],x[1],x[2]],[x[3],x[4],x[5]],[x[6],x[7],1]])
    return H/np.linalg.norm(H)

def RANSAC_pipeline(kp1,kp2):
    sig = 2
    delta = 3*sig
    eps = 0.3
    p = 0.99
    n = 6
    N = int((np.log(1-p)/np.log(1-np.power((1-eps),n))))+1
    M = int(((1-eps)*len(kp1)))
    print(f"N:{N}, M:{M}")
    one_vec = np.ones((len(kp1),1),dtype=np.uint8)
    kp1_HC = np.hstack((kp1,one_vec))
    kp2_HC = np.hstack((kp2,one_vec))

    # print(pt1_HC.shape)
    inlier_set = np.array([])
    for i in range(N):
        #print(i)
        idx = np.random.randint(len(kp1),size=n)
        pt1 = np.array(kp1)[idx]
        pt2 = np.array(kp2)[idx]
        H = find_H(pt1,pt2)

        pt1_2_pt2 = H@np.transpose(kp1_HC)
        pt1_2_pt2/= pt1_2_pt2[2]
        pt1_2_pt2 = np.transpose(np.round(pt1_2_pt2))

        dist = (np.linalg.norm(kp2_HC - pt1_2_pt2,axis=1))
        #print(dist)

        inliers_pos = dist <= delta
        # outlier_pos = ~inliers_pos
        # print(inliers_pos)

        if sum(inlier_set) < sum(inliers_pos):
            inlier_set = inliers_pos
        #print(sum(inlier_set))

    rerun_count = 0

    if sum(inlier_set) < M:
        print('Inlier set less than M !')
        if rerun_count < 3:
            print('Rerun....')
            rerun_count+=1
            return RANSAC_pipeline(kp1,kp2)

    else:
        kp1_inlier = kp1_HC[inlier_set][:,:2]
        kp2_inlier = kp2_HC[inlier_set][:,:2]
        kp1_outlier = kp1_HC[~inlier_set][:,:2]
        kp2_outlier = kp2_HC[~inlier_set][:,:2]
        #taking phy. coordinates as 3rd element is 1

        print('#inliers',sum(inlier_set))
        return [(kp1_inlier,kp2_inlier),(kp1_outlier,kp2_outlier)]

# inliers,outliers=RANSAC_pipeline(kp1,kp2)
# print(inliers)

def plot_correspondences(img1,img2,inliers,outliers):

    # Combined img with correspondences
    height = max(img1.shape[0], img2.shape[0])
    width = img1.shape[1] + img2.shape[1]
    combined_img = np.zeros((height, width, 3), dtype=np.uint8)
    combined_img[:img1.shape[0], :img1.shape[1]] = img1
    combined_img[:img2.shape[0], img1.shape[1]:] = img2
    # lines for corresponding points
    for pt1, pt2 in zip(inliers[0], inliers[1]):
        pt2_shifted = (pt2[0] + img1.shape[1], pt2[1])
        cv.line(combined_img, pt1, pt2_shifted, (0, 255, 0), 1)
    for pt1, pt2 in zip(outliers[0], outliers[1]):
        pt2_shifted = (pt2[0] + img1.shape[1], pt2[1])
        cv.line(combined_img, pt1, pt2_shifted, (0, 0, 255), 1)

    plt.imshow(combined_img[:,:,::-1])
    plt.title('inliers(G) and outliers(R)')
    plt.show()

    print('---------------------------------------------------------------------------------')

# plot_correspondences(image1,image2,inliers,outliers)

def cost_func(H,pt1,pt2):
    H = H.reshape((3,3))
    one_vec = np.ones((len(pt1),1),dtype=np.uint8)
    pt1_HC = np.hstack((pt1,one_vec))
    pt2_HC = np.hstack((pt2,one_vec))

    pt1_2_pt2 = H@np.transpose(pt1_HC)
    pt1_2_pt2/= pt1_2_pt2[2]
    pt1_2_pt2 = np.transpose(np.round(pt1_2_pt2))

    err = pt2 - pt1_2_pt2[:,:2]

    return err.reshape(-1)

def get_refined_H(img1,img2,method='LM'):
    kp1, kp2 = SIFT_algo(img1,img2)
    inliers,outliers=RANSAC_pipeline(kp1,kp2)
    plot_correspondences(img1,img2,inliers,outliers)

    if method=='LM':
        H = find_H(inliers[0],inliers[1])
        refined_H = optimize.least_squares(cost_func,H.flatten(),method='lm',args=(inliers[0],inliers[1]))
        refined_H = refined_H.x
        return refined_H.reshape((3,3))

#transforming pixel coordinates
def transform(image_d,H):
    img_dim = np.array([[0,0],[image_d.shape[1],0],[image_d.shape[1],image_d.shape[0]],[0,image_d.shape[0]]])
    rng_dim = np.zeros(img_dim.shape,dtype=int)
    for i in range(len(img_dim)):
        x = np.append(img_dim[i],[1])
        x_d = H@x
        rng_dim[i][0] = int(x_d[0]/x_d[2])
        rng_dim[i][1] = int(x_d[1]/x_d[2])

    y_lim,x_lim = max(rng_dim[:,1])-min(rng_dim[:,1]),max(rng_dim[:,0])-min(rng_dim[:,0])
    image_r = np.zeros((y_lim,x_lim,3),dtype=int)

    for j in range(y_lim):
        for i in range(x_lim):
            x = np.array([i+min(rng_dim[:,0]), j+min(rng_dim[:,1]), 1])
            x_d = np.linalg.inv(H)@x
            xi = int(x_d[0]/x_d[2])
            xj = int(x_d[1]/x_d[2])
            if 0<= xj <image_d.shape[0] and 0<= xi < image_d.shape[1]:
                image_r[j,i] = image_d[xj,xi]
    return image_r,rng_dim

#making panoramic view
def make_panorama(img_list,method='LM'):

    H_12 = get_refined_H(img_list[0],img_list[1],method='LM')
    H_23 = get_refined_H(img_list[1],img_list[2],method='LM')
    H_34 = get_refined_H(img_list[2],img_list[3],method='LM')
    H_45 = get_refined_H(img_list[3],img_list[4],method='LM')

    print(H_12)
    print(H_23)
    print(H_34)
    print(H_45)

    #tranform to middle img 3
    H1 = H_23@H_12
    H2 = H_23
    H3 = np.eye(3)
    H4 = np.linalg.inv(H_34)
    H5 = np.linalg.inv(H_34)@np.linalg.inv(H_45)

    H_list = [H1,H2,H3,H4,H5]

    projected_imgs = []
    projected_imgs_dim = []
    for i in range(len(img_list)):
        # print('Projected Image: ',i+1)
        tf,tf_dim = transform(img_list[i],H_list[i])
        projected_imgs.append(tf)
        projected_imgs_dim.append(tf_dim)
        # plt.imshow(tf[:,:,::-1])
        # plt.show()


    projected_imgs_dim = np.array(projected_imgs_dim)
    y_lim = projected_imgs_dim[:,:,1].max() - projected_imgs_dim[:,:,1].min()

    x_lim = 0
    for i in range(len(projected_imgs_dim)):
        if i< len(projected_imgs_dim)-1:
            x_lim+=projected_imgs_dim[:,:,0][i+1].min() - projected_imgs_dim[:,:,0][i].min()
        else:
            x_lim+=projected_imgs_dim[:,:,0][i].max() - projected_imgs_dim[:,:,0][i].min()

    stitched_img = np.zeros((y_lim,x_lim,3),dtype=int)
    # print(stitched_img.shape)

    for i in range(len(projected_imgs_dim)):
        shift_x = projected_imgs_dim[:,:,0][i].min() - projected_imgs_dim[:,:,0].min()
        shift_y = projected_imgs_dim[:,:,1][i].min() - projected_imgs_dim[:,:,1].min()
        # print(shift_x,shift_y)
        background = stitched_img[shift_y:shift_y+projected_imgs[i].shape[0], shift_x:shift_x+projected_imgs[i].shape[1]]
        background = np.where(background==0,projected_imgs[i],background)
        stitched_img[shift_y:shift_y+projected_imgs[i].shape[0], shift_x:shift_x+projected_imgs[i].shape[1]] = background
        # plt.imshow(stitched_img[:,:,::-1])
        # plt.show()

    plt.imshow(stitched_img[:,:,::-1])
    plt.show()

    return projected_imgs,projected_imgs_dim

#projected_imgs,projected_imgs_dim = make_panorama(image_list,method='LM')



if __name__ == "__main__":

    image1 = cv.imread('/content/sf_11.jpg')
    image2 = cv.imread('/content/sf_22.jpg')
    image3 = cv.imread('/content/sf_33.jpg')
    image4 = cv.imread('/content/sf_44.jpg')
    image5 = cv.imread('/content/sf_55.jpg')

    image_list = [image1,image2,image3,image4,image5]

    projected_imgs_2,projected_imgs_dim_2 = make_panorama(image_list,method='LM')



    image1 = cv.imread('/content/sf_1.jpg')
    image2 = cv.imread('/content/sf_2.jpg')
    image3 = cv.imread('/content/sf_3.jpg')
    image4 = cv.imread('/content/sf_4.jpg')
    image5 = cv.imread('/content/sf_5.jpg')

    image_list = [image1,image2,image3,image4,image5]

    projected_imgs_1,projected_imgs_dim_1 = make_panorama(image_list,method='LM')

